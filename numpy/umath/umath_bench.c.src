/*
 * Copyright (C) 2017 Intel Corporation
 *
 * SPDX-License-Identifier: MIT
 */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include "mkl.h"
#include <assert.h>
#include "rdtsc.h"
#include <complex.h>
#include <mathimf.h>

#define SEED 77777

/*
 * Inner timing loop, emitting CPE. Note that this is just a glorified
 * for-loop!
 *
 * reps - number of repetitions
 * n - problem size
 * j - temporary iteration variable
 * t0, t1 - temporary timing variables (rdtsc_type)
 * cpe - cpe variable to set
 * cpe_min - cpe_min variable to set
 */
#define TIME_CPE(reps, n, j, t0, t1, cpe, cpe_min) \
    cpe_min = 100000000.0; \
    for (j = 0; t0 = timer_rdtsc(), j < reps; t1 = timer_rdtsc(), \
         cpe = ((double) (t1 - t0) / n), \
         cpe_min = cpe < cpe_min ? cpe : cpe_min, j++)

#define PRINT_LINE(impl, func, prefix, n, cpe) \
    printf("%s, " impl ", " func ", %ld, %.4g\n", prefix, n, cpe);

static void _print_mkl_version() {
    int len = 198;
    char buf[198];

    mkl_get_version_string(buf, len);
    printf("\nMKL Version: %s\n", buf);
}

#define EXPERIMS_N 3
#define REPS_N 100

typedef struct experiment_t {
    long array_size;
    long repetitions;
} experiment_t;

static void populate_experiment_sizes(experiment_t *list, int s0, size_t n) {
  int i;
  long s, r;
  long r_max = (1 << 16);

  s = (1 << s0);
  r = (2 << n);

  for(i=0; i < n; i++) {
    list[i].array_size = s;
    list[i].repetitions = (r > r_max) ? r_max : r;
    s <<= 1;
    r >>= 1;
  }

  return;
}

int main(int argc, char **argv) {
    VSLStreamStatePtr stream;
    double *x1, *x2, *y, CPE, CPE_min;
    double c = 4321.43;
    int err = 0;
    size_t j, i, k, l;
    const double d_zero = 0.0, d_one = 1.0;
    experiment_t experims[EXPERIMS_N];
    rdtsc_type t0, t1;
    long int arraySize = argc>1?atol(argv[1]):2500000;
    long int n = arraySize;
    char *prefix = argc>2?argv[2]:"@";

    populate_experiment_sizes(experims, 2, EXPERIMS_N);

    err = vslNewStream(&stream, VSL_BRNG_SFMT19937, SEED);
    assert(err == VSL_STATUS_OK);

    {
        long int n = arraySize;

        x1 = (double *) mkl_malloc( n*sizeof(double), 64);
        x2 = (double *) mkl_malloc( n*sizeof(double), 64);
        y  = (double *) mkl_malloc( n*sizeof(double), 64);

        err = vdRngExponential(VSL_RNG_METHOD_EXPONENTIAL_ICDF_ACCURATE,
                               stream, n, x1, d_zero, d_one);
        assert(err == VSL_STATUS_OK);
        err = vdRngExponential(VSL_RNG_METHOD_EXPONENTIAL_ICDF_ACCURATE,
                               stream, n, x2, d_zero, d_one);
        assert(err == VSL_STATUS_OK);
    }

#define TIME_CPE_HERE TIME_CPE(REPS_N, n, j, t0, t1, CPE, CPE_min)
#define PRINT_LINE_HERE(impl, func) PRINT_LINE(impl, func, prefix, n, CPE_min)

    int experiments;
    for (experiments = 0; experiments < EXPERIMS_N; experiments++) {

/**begin repeat
 *  #func = +, -, *, /#
 *  #vml = Add, Sub, Mul, Div#
 */
        TIME_CPE_HERE {
            vd@vml@(n, x1, x2, y);
        }
        PRINT_LINE_HERE("VML", "array@func@array");

        TIME_CPE_HERE {
#pragma omp parallel for
            for (l = 0; l < n; l++) {
                y[l] = x1[l] @func@ x2[l];
            }
        }
        PRINT_LINE_HERE("SVML", "array@func@array");


/**end repeat**/

/**begin repeat
 *  #func=   +,   -,   *#
 *  #in1 =   n,   n,   n#
 *  #in2 =  x1,  x1,  x1#
 *  #in3 =  x1,  x1,  x1#
 *  #in4 = 1.0, 1.0,   c#
 *  #in5 =   c,  -c, 0.0#
 *  #in6 = 0.0, 0.0, 0.0#
 *  #in7 = 1.0, 1.0, 1.0#
 *  #in8 =   y,   y,   y#
 */

        TIME_CPE_HERE {
            vdLinearFrac(@in1@, @in2@, @in3@, @in4@, @in5@, @in6@, @in7@,
                         @in8@);
        }
        PRINT_LINE_HERE("VML", "array@func@scalar");

        TIME_CPE_HERE {
#pragma omp parallel for
            for(l=0; l < n; l++) {
                y[l] = x1[l] @func@ c;
            }
        }
        PRINT_LINE_HERE("SVML", "array@func@scalar");

/**end repeat**/

        TIME_CPE_HERE {
#pragma omp parallel for
            for(l=0; l < n; l++) {
                y[l] = x1[l] / c;
            }
        }
        PRINT_LINE_HERE("SVML", "array/scalar");

/**begin repeat
 *  #func = log10, exp, erf#
 *  #vml =  Log10, Exp, Erf#
 */

        TIME_CPE_HERE {
            vd@vml@(n, x1, y);
        }
        PRINT_LINE_HERE("VML", "@func@");

        TIME_CPE_HERE {
#pragma omp parallel for
            for(l=0; l < n; l++) {
                y[l] = @func@(x1[l]);
            }
        }
        PRINT_LINE_HERE("SVML", "@func@");

/**end repeat**/

        TIME_CPE_HERE {
            vdInvSqrt(n, x1, y);
        }
        PRINT_LINE_HERE("VML", "invsqrt");

        TIME_CPE_HERE {
#pragma omp parallel for
            for(l=0; l < n; l++) {
                y[l] = 1 / sqrt(x1[l]);
            }
        }
        PRINT_LINE_HERE("SVML", "invsqrt");
    }

    if (x1)
        mkl_free(x1);
    if (x2)
        mkl_free(x2);
    if (y)
        mkl_free(y);

    err = vslDeleteStream(&stream);
    assert(err == VSL_STATUS_OK);
}
